\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{minted}

\title{Documentation du Projet en Rust}
\author{Votre Nom}
\date{\today}

\begin{document}

\maketitle

\section*{Introduction}
Ce projet en Rust est une application permettant de manipuler et de rechercher des vecteurs dans une base de données. Il utilise des concepts comme les embeddings vectoriels, la similarité cosinus, et une base de données interne basée sur un \texttt{HashMap}. Le projet génère des embeddings aléatoires et recherche les vecteurs les plus similaires en termes de similarité cosinus.

\section*{Structure du Code}
Le projet est divisé en plusieurs parties :
\begin{itemize}
    \item Une fonction pour générer des embeddings aléatoires.
    \item Une fonction pour calculer la similarité cosinus entre deux vecteurs.
    \item Une structure \texttt{Db} encapsulant un \texttt{HashMap} pour stocker les vecteurs.
    \item Une méthode pour rechercher les vecteurs les plus similaires dans la base de données.
    \item Une fonction \texttt{main} pour orchestrer l'exécution.
\end{itemize}

\section*{Code Source}

\subsection*{Fonction pour générer un embedding aléatoire}
\begin{minted}[frame=lines,fontsize=\small,linenos]{rust}
fn generer_embedding(dimension: usize) -> Vec<f32> {
    let mut rng = rand::thread_rng();
    (0..dimension).map(|_| rng.gen_range(0.0..1.0)).collect()
}
\end{minted}

Cette fonction génère un vecteur de taille \texttt{dimension} avec des valeurs aléatoires comprises entre 0 et 1.

\subsection*{Fonction pour calculer la similarité cosinus}
\begin{minted}[frame=lines,fontsize=\small,linenos]{rust}
fn calcul_similarite(vec1: &[f32], vec2: &[f32]) -> f32 {
    let produit: f32 = vec1.iter().zip(vec2).map(|(a, b)| a * b).sum();
    let vec1: f32 = vec1.iter().map(|x| x * x).sum::<f32>().sqrt();
    let vec2: f32 = vec2.iter().map(|x| x * x).sum::<f32>().sqrt();

    if vec1 == 0.0 || vec2 == 0.0 {
        0.0
    } else {
        produit / (vec1 * vec2)
    }
}
\end{minted}

Cette fonction calcule la similarité cosinus entre deux vecteurs en évitant la division par zéro.

\subsection*{Structure \texttt{Db} et ses méthodes}
\begin{minted}[frame=lines,fontsize=\small,linenos]{rust}
struct Db {
    inner: HashMap<Uuid, Vec<f32>>,
}

impl Db {
    fn new() -> Self {
        Db {
            inner: HashMap::new(),
        }
    }

    fn insert(&mut self, uuid: Uuid, embedding: Vec<f32>) {
        self.inner.insert(uuid, embedding);
    }

    fn trouver_les_plus_similaires(&self, query: &[f32], n: usize) -> Vec<(Uuid, f32)> {
        let mut similarities: Vec<(Uuid, f32)> = self
            .inner
            .iter()
            .map(|(uuid, embedding)| (*uuid, calcul_similarite(query, embedding)))
            .collect();

        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        similarities.into_iter().take(n).collect()
    }
}
\end{minted}

La structure \texttt{Db} contient une base de données interne sous forme de \texttt{HashMap} et permet d'insérer des vecteurs et de trouver les vecteurs les plus similaires.

\subsection*{Fonction \texttt{main}}
\begin{minted}[frame=lines,fontsize=\small,linenos]{rust}
fn main() {
    let mut db = Db::new();
    let embedding_dimension = 768;

    for _ in 0..10 {
        let uuid = Uuid::new_v4();
        let embedding = generer_embedding(embedding_dimension);
        db.insert(uuid, embedding);
    }

    let query_embedding = generer_embedding(embedding_dimension);
    let plus_similaire = db.trouver_les_plus_similaires(&query_embedding, 3);

    println!("Les 3 vecteurs les plus similaires :");
    for (uuid, similarity) in plus_similaire {
        println!("UUID: {}, Similarité: {:.4}", uuid, similarity);
    }
}
\end{minted}

La fonction \texttt{main} crée une base de données, y insère des vecteurs aléatoires, génère un vecteur de requête, et affiche les trois vecteurs les plus similaires.

\section*{Conclusion}
Ce projet démontre l'utilisation efficace de Rust pour manipuler des données vectorielles, calculer des similarités, et effectuer des recherches performantes dans une base de données interne. Il peut être étendu pour intégrer des fonctionnalités supplémentaires comme la persistance des données ou l'optimisation des calculs.

\end{document}
